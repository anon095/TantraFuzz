package mutation

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/anon095/TantraFuzz/internal/analyzer"
	"github.com/anon095/TantraFuzz/internal/api"
	ctx "github.com/anon095/TantraFuzz/internal/context"
	"github.com/anon095/TantraFuzz/internal/payload"
)

// Mutator uses an AI client to create new payloads.
type Mutator struct {
	aiClient *api.Client
}

// NewMutator creates a new mutator instance.
func NewMutator(aiClient *api.Client) *Mutator {
	return &Mutator{aiClient: aiClient}
}

// MutateWithAI asks the Gemini AI to create a mutated version of a given payload
// using rich context about the target and the last failed attempt.
func (m *Mutator) MutateWithAI(
	p payload.Payload,
	targetCtx *ctx.TargetContext,
	lastResult *analyzer.AnalysisResult,
) (*payload.Payload, error) {
	log.Printf("ðŸ§  Activating Higher Consciousness to mutate payload: '%s'", p.Content)

	// --- Dynamic AI Prompt Engineering ---
	var promptBuilder strings.Builder
	promptBuilder.WriteString("You are an elite cybersecurity expert specializing in creating payloads to bypass Web Application Firewalls (WAFs) and input filters.\n\n")
	
	// Add static context from the recon scan
	promptBuilder.WriteString("== Target Context ==\n")
	promptBuilder.WriteString(fmt.Sprintf("- Detected WAF: %s\n", targetCtx.WAF))
	promptBuilder.WriteString(fmt.Sprintf("- Detected Technologies: %v\n", targetCtx.Technologies))
	promptBuilder.WriteString("\n")

	// Add dynamic context from the last failed request
	promptBuilder.WriteString("== Last Attempt Analysis ==\n")
	promptBuilder.WriteString(fmt.Sprintf("- Original Payload: %s\n", p.Content))
	if lastResult.IsBlocked {
		promptBuilder.WriteString(fmt.Sprintf("- Result: FAILED (Blocked). Reason: %s\n", lastResult.BlockReason))
	} else if lastResult.IsReflected {
		promptBuilder.WriteString(fmt.Sprintf("- Result: FAILED (No vulnerability). However, the payload was reflected in a '%s' context.\n", lastResult.ReflectionContext))
	} else {
		promptBuilder.WriteString("- Result: FAILED (No vulnerability). The payload was not reflected.\n")
	}
	promptBuilder.WriteString("\n")

	// The final instruction for the AI
	promptBuilder.WriteString("== Your Task ==\n")
	promptBuilder.WriteString("Based on all the context above, generate a SINGLE, mutated, more evasive version of the original payload. Your goal is to bypass the detected defenses within the given reflection context.\n")
	promptBuilder.WriteString("Return ONLY the raw, mutated payload string. Do not include any explanations, introductory text, or formatting.\n\n")
	promptBuilder.WriteString("Mutated Payload:")

	prompt := promptBuilder.String()

	mutatedContent, err := m.aiClient.GenerateContent(context.Background(), prompt)
	if err != nil {
		return nil, fmt.Errorf("ai content generation failed: %w", err)
	}
    
    // Clean up the AI's response
    mutatedContent = strings.TrimSpace(mutatedContent)
    mutatedContent = strings.Trim(mutatedContent, "`")


	// Create a new payload struct for the mutated version
	mutatedPayload := &payload.Payload{
		Content: mutatedContent,
		Source:  "AI-Mutated from: " + p.Content,
		Target:  p.Target,
		Purpose: "AI-generated bypass based on behavioral analysis",
	}

	log.Printf("âœ¨ AI has generated a new payload: %s", mutatedPayload.Content)
	return mutatedPayload, nil
}
